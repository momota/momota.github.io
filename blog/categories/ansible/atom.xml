<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ansible | momota.txt]]></title>
  <link href="http://momota.github.io/blog/categories/ansible/atom.xml" rel="self"/>
  <link href="http://momota.github.io/"/>
  <updated>2016-08-11T19:51:08+09:00</updated>
  <id>http://momota.github.io/</id>
  <author>
    <name><![CDATA[momota]]></name>
    <email><![CDATA[makoto.momota@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ansible で MacBook Pro をセットアップ]]></title>
    <link href="http://momota.github.io/blog/2016/08/10/ansible-mac/"/>
    <updated>2016-08-10T15:15:00+09:00</updated>
    <id>http://momota.github.io/blog/2016/08/10/ansible-mac</id>
    <content type="html"><![CDATA[<p>MacBook Pro 2700/13.3 MF839J/A を購入したので (わーい) 、構成管理ツール ansible を使ってセットアップした。</p>

<p><img src="/images/20160810_macbookpro.jpg" alt="macbook pro" /></p>

<p>t-wada さんのエントリ <a href="http://t-wada.hatenablog.jp/entry/mac-provisioning-by-ansible">Mac の開発環境構築を自動化する (2015 年初旬編) &ndash; t-wadaのブログ変更する</a>
を見れば事足りると思われるので、本稿は自分用のメモ(t-wada さんのを少しだけカスタマイズ &amp; 補足)。</p>

<!-- more -->


<h1>1. 事前準備</h1>

<h2>1.1. SSH</h2>

<p>ansible では、コントローラ (Control Machine) から SSH 越しで管理対象ノード (Managed Node) を操作する。
今回は Control Machine も Managed Node も同一マシン (Macbook) なので、localhost に SSH できるようにする。</p>

<p>まず SSH の許可設定。
Mac で「システム環境設定」 > 「共有」 > 「リモートログイン」にチェック。</p>

<p>次にパスなしログインするために公開鍵を設定する。
<a href="http://momota.github.io/blog/2016/02/08/ansible/">こちらでも紹介したとおり</a>、以下のようにする。</p>

<p>```sh</p>

<h1>no-pass SSH key を生成</h1>

<p>$ ssh-keygen -t rsa</p>

<h1>authorized_keysの登録</h1>

<p>$ cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys
$ chmod 600 ~/.ssh/authorized_keys</p>

<h1>SSH アクセス確認</h1>

<p>$ ssh 127.0.0.1
```</p>

<h2>1.2. Xcode</h2>

<p>Homebrew をインストールするために必要なので、App Store から XCode をインストールする。
XCode インストール後、ライセンス同意する。</p>

<p><code>sh
$ sudo xcode build -license
</code></p>

<p>ライセンス規約みたいな文章がつらつらと出てくるので、最後に「agree」と入力する。</p>

<p>XCode のコマンドラインツールもインストールする。</p>

<p><code>sh
$ xcode-select --install
</code></p>

<h2>1.3. Homebrew</h2>

<p>Homebrew は Mac 用のパッケージマネージャ (yum とか apt 的なやつ。
Homebrew って、ホームブリューと読んでいるけどホームブルーのほうが正しい発音ぽい)。</p>

<p><a href="http://brew.sh/index_ja.html">公式サイト</a>の案内に従い、以下のワンライナーで Homebrew をインストールする。</p>

<p><code>sh
$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
</code></p>

<p>上記ワンライナーでインストールするとたぶん最新版がインストールされるが、インストール後 <code>brew doctor</code> で古いと出力されたらアップデートする。</p>

<p><code>sh
$ brew doctor
$ brew update
</code></p>

<h2>1.4. Ansible</h2>

<p>Ansible に必要な python はすでに 2.7 系がプリインストールされていたので、
そのまま Homebrew で Ansible をインストールする。</p>

<p><code>
$ brew install ansible
$ ansible --version
</code></p>

<h1>2. Ansible Playbook を開発する</h1>

<p>前回の <a href="http://momota.github.io/blog/2016/02/08/ansible/">Ansible でノート PC をセットアップ</a> で作った仕組みにのせる。</p>

<p>t-wada さんの場合、1 枚の Playbook に変数やタスクを記述していたが、ありものは活用したいという思いがあり。</p>

<p>今回は以下のようなアレンジをした。</p>

<ul>
<li>インストールするパッケージを列挙した変数を <code>vars/common.yml</code> に切り出す
```yaml

<h1>for MacOSX</h1>

homebrew_taps:

<ul>
<li>homebrew/versions</li>
<li>homebrew/binary</li>
<li>homebrew/dupes</li>
<li>caskroom/cask</li>
<li>sanemat/font
homebrew_packages:</li>
<li>{ name: readline }</li>
<li>{ name: openssl }

<h1>(略)</h1>

<p>homebrew_cask_packages:</p></li>
<li>{ name: iterm2 }</li>
<li>{ name: firefox }</li>
<li>{ name: google-chrome }</li>
<li>{ name: google-japanese-ime }

<h1>(略)</h1>

<p>```</p></li>
</ul>
</li>
<li>CentOS などへもインストールするような共通のパッケージは <code>common/</code> 以下の role を利用する

<ul>
<li>今回は tmux とzsh のみ</li>
</ul>
</li>
<li>Mac 固有のタスクは、<code>mac/</code> 以下に切り出す

<ul>
<li>brew (cask も) 用のrole を作る</li>
<li>ricty フォントインストールは個別の処理が多かったため別の role で切り出す</li>
</ul>
</li>
<li>インベントリファイル <code>hosts</code> に mac 用グループ <code>[mac]</code> を作る
<code>ini
[mac]
127.0.0.1
</code></li>
</ul>


<p>ディレクトリ構造は以下のようになった。</p>

<p>```
└── laptop-build</p>

<pre><code>├── centos
│   ├── docker
│   │   ├── files
│   │   └── tasks
│   └── yum
│       └── tasks
├── common
│   ├── dotfiles
│   │   ├── meta
│   │   └── tasks
│   ├── dstat
│   │   └── tasks
│   ├── guest_account
│   │   └── tasks
│   ├── ruby
│   │   ├── meta
│   │   └── tasks
│   ├── tmux
│   │   └── tasks
│   ├── vim
│   │   └── tasks
│   └── zsh
│       └── tasks
├── mac
│   ├── brew
│   │   └── tasks
│   └── ricty
│       ├── handlers
│       └── tasks
└── vars
</code></pre>

<p>```</p>

<p>できあがった Playbook は Github にあげた。 <a href="https://github.com/momota/laptop-build">momota/laptop-build</a></p>

<h1>3. Ansible を実行する</h1>

<h2>3.1. ansible のログ出力設定</h2>

<p><code>tee</code> とかを使って Playbook の実行出力結果をファイルに保存しようと思ったが、ansible のログ機能を使った。
<code>ansible.cfg</code> に以下を記述。</p>

<p><code>ini
[defaults]
log_path=/var/log/ansible.log
</code></p>

<p>mac の場合、<code>/etc/ansible/ansible.cfg</code> がなかった (ディレクトリごとない) ので、<code>~/.ansible.cfg</code> を作成した。</p>

<h2>3.2. ansible の実行</h2>

<p>absible-playbook コマンドで実行する。</p>

<p>```sh</p>

<h1>git clone</h1>

<p>$ git clone <a href="https://github.com/momota/laptop-build">https://github.com/momota/laptop-build</a>
$ cd laptop-build</p>

<h1>execute playbook</h1>

<p>$ HOMEBREW_CASK_OPTS=&ldquo;&mdash;appdir=/Applications&rdquo; ansible-playbook -i hosts mac/site.yml -vv -K
```</p>

<p><code>HOMEBREW_CASK_OPTS="--appdir=/Applications"</code> をつけないと、アプリケーションによって <code>/Applications</code> だったり、 <code>~/Applications</code> だったりにシンボリックリンクリンクが作られてしまうとのこと。</p>

<p>ログインシェルを zsh に変更するタスクで <code>sudo</code> するので、<code>-K</code> オプション付き。</p>

<h1>4. Playbook のトラブルフォロー</h1>

<h2>4.1. shell モジュールでcommand not found</h2>

<p>Playbook をコピペして実行したら、shell モジュールで <code>brew</code> を呼んでいるタスクから
<code>command not found</code> エラーが返ってきた。
フルパスで指定し直す。</p>

<h2>4.2. cask パッケージ名の誤り</h2>

<p><code>/vars/common.yml</code> にインストールしたい cask パッケージ名を定義するが、パッケージ名を謝って途中で処理がこけた。
もちろんググっても良いと思うが、事前に以下のコマンドなどで調べるとよさそう。</p>

<p><code>sh
$ brew cask search [探したいパッケージ]
</code></p>

<h2>4.3. cask インストールの処理停止</h2>

<p>Homebrew cask でパッケージインストール途中で処理が止まることがあった。(2, 3回)
どんなに待っても止まったままなので、 <code>Ctrl-c</code> で中断する。</p>

<p>ansible-playbook コマンドに <code>-vvv</code> オプションなどを付けるも、原因はよく分からず。
たぶん、ansible ではなく brew 側に原因がありそう。</p>

<p>インストール処理で止まっているパッケージは、ansible で表示されているパッケージの、<code>vars/common.yml</code> での変数定義上の次のパッケージ。
途中で止まっているパッケージもインストール一覧に出力される。</p>

<p>```sh
$ brew cask list</p>

<h1>=> インストール処理中のパッケージも出力される</h1>

<p>```</p>

<p>リストには表示されるものの、中途半端にインストールされていそうなので、
<code>brew</code> コマンドでインストールし直して Playbook を再実行する。</p>

<p>```sh
$ brew cask install &mdash;force [途中で止まったパッケージ]</p>

<h1>アンインストールして、再インストールしても良いかも</h1>

<h1>$ brew cask uninstall [途中で止まったパッケージ]</h1>

<h1>$ brew cask install [途中で止まったパッケージ]</h1>

<p>$ HOMEBREW_CASK_OPTS=&ldquo;&mdash;appdir=/Applications&rdquo; ansible-playbook -i hosts mac/site.yml -vv -K
```</p>

<p>なにも考えずに re-run できるのはうれしい。 (これが冪等性のパワーか)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ansible でノートPCをセットアップ]]></title>
    <link href="http://momota.github.io/blog/2016/02/08/ansible/"/>
    <updated>2016-02-08T09:42:00+09:00</updated>
    <id>http://momota.github.io/blog/2016/02/08/ansible</id>
    <content type="html"><![CDATA[<p><a href="http://momota.github.io/blog/2015/11/15/centos-install/">CentOS 7 を USB メモリからインストール</a> で書いたが、まっさらなCentOSが手元にあったので
<a href="http://www.ansible.com/">ansible</a> を使っていろいろインストールしてみた。</p>

<p>ちょっと前に、<a href="http://www.ansible.com/blog/ansible-2.0-launch">Ansible 2.0 Has Arrived</a> という記事も話題になってたし。</p>

<p>ansible は Chef のような構成管理ツール。
システムの設定や、ソフトウェアのデプロイ、オーケストレーションなどが可能なIT自動化ツール。
管理対象ノードが多いほどメリットが大きい。</p>

<p>Chef と比較すると、エージェントレスのアーキテクチャで、Chefのように特定言語(Ruby)を学ぶ必要はなく、YAMLで構成を表現する。
これは、Playbookと呼ばれる。Chef でいうレシピ。</p>

<p>マネージャ側は最近は大抵プリインストールされている python とansible さえインストールすればよい。
クライアント側は、マネージャから SSH アクセスさえできればよい。</p>

<p>これを1回やってファイル群をリポジトリで管理しておけば、環境の複製が楽になるし、Infrastructure as a Code ですね。</p>

<!-- more -->


<p>まず、環境の説明。</p>

<p><img src="/images/ansible.png" alt="ansible_diag" /></p>

<p>本稿では、ansible実行サーバをコントローラ (Control Machine)、ansibleによる
管理対象ノードを管理ノード (Managed Node) と呼ぶことにする。</p>

<table>
<thead>
<tr>
<th>役割                           </th>
<th> ホスト名     </th>
<th> 物理マシン     </th>
<th> IPアドレス</th>
</tr>
</thead>
<tbody>
<tr>
<td>コントローラ (Control Machine) </td>
<td> controller   </td>
<td> mac mini       </td>
<td> 192.168.11.9/24</td>
</tr>
<tr>
<td>管理ノード   (Managed Node)    </td>
<td> managed_node </td>
<td> TOSHIBA laptop </td>
<td> 192.168.11.14/24</td>
</tr>
</tbody>
</table>


<p>ansible のバージョンは <code>2.0.0.2</code>。</p>

<h1>0. 準備</h1>

<h2>0-1. コントローラ</h2>

<ol>
<li>ansible をインストールする
<code>sh
controller$ brew install ansible
</code></li>
</ol>


<h2>0-2. 管理ノード</h2>

<p>コントローラ～管理ノード間は、ネットワークを介して管理される。
コントローラから管理ノードへSSHアクセスできる必要があるので、以下の設定を事前に行っておく。</p>

<ol>
<li>管理ノードのネットワーク設定</li>
<li>コントローラのSSH公開鍵の登録
```sh

<h1>コントローラ側no-pass SSH key を生成</h1>

controller$ ssh-keygen -t rsa

<h1>mac には ssh-copy-id がないので、scpで公開鍵をコピー</h1>

<p>controller$ scp ~/.ssh/id_dsa.pub 192.168.11.14:/home/momota</p></li>
</ol>


<h1>管理ノード側でauthorized_keysの登録</h1>

<p>managed_node$ mkdir ~/.ssh
managed_node$ chmod 700 ~/.ssh
managed_node$ cat id_dsa.pub >> ~/.ssh/authorized_keys
managed_node$ chmod 600 ~/.ssh/authorized_keys</p>

<h1>SSH アクセス確認</h1>

<p>controller$ ssh 192.168.11.14
```</p>

<h1>1. ansible 設定</h1>

<p>まずは、管理ノードへOSアカウント (guestユーザ) を追加作成してみる。</p>

<p>ディレクトリ構成は、<a href="http://qiita.com/yteraoka/items/5ed2bddefff32e1b9faf">Ansible オレオレベストプラクティス</a> を参考にして以下のように作成。</p>

<p><code>``sh
controller$ tree laptop_build
laptop_build
|-- centos
|   |-- hosts
|  </code>&mdash; site.yml
|&mdash; common
|   |&mdash; guest_account
|   |   <code>-- tasks
|   |      </code>&mdash; main.yml
|&mdash; private_vars
|   <code>-- common.yml
</code>&mdash; vars</p>

<pre><code>`-- common.yml
</code></pre>

<p>```</p>

<p>それぞれのディレクトリの位置づけは、<a href="http://yteraoka.github.io/ansible-tutorial/">Ansibleチュートリアル</a>とかを参照するとわかりやすい。</p>

<p>まずは、<code>centos/hosts</code> へ管理ノードのIPアドレスを登録する。
クライアントが複数ある場合は、このエントリーで複数のアドレスを列挙すればよい。</p>

<p><code>yaml
[laptops]
192.168.11.14
</code></p>

<p>次に、メイン処理を <code>centos/site.yml</code> に記述する。
外部ファイルをインクルードして、roleの実行順序を指定するだけ。
<code>hosts</code> のところで、対象を絞れるが、今回は all。うまく使えば、production用とdevelopment用を使い分けたりグループ単位で実行できる。</p>

<p>```yaml
&ndash; hosts: all
  vars_files:</p>

<pre><code>- ../vars/common.yml
- ../private_vars/common.yml
</code></pre>

<p>  roles:</p>

<pre><code>- ../common/guest_account
</code></pre>

<p>```</p>

<p><code>vars/common.yml</code> には Playbook 共通で使いたい変数を設定している。</p>

<p><code>private_vars/common.yml</code> には公開したくない変数を設定している。ここでは、guestユーザのパスワードを以下のように指定している。</p>

<h2>```yaml</h2>

<p>guest_password: &ldquo;hogehoge&rdquo;
```</p>

<p>こういうパスワードみたいな情報をgithubに上げたくないので、.gitignoreには
private_vars/ を追加しておく。</p>

<p><code>roles</code> には、実際のアカウント追加処理を指定している role ディレクトリ<code>common/guest_account</code>を指定する。</p>

<p><code>common/guest_account/tasks/main.yml</code> には、userモジュールを使って、以下のようにタスクを記述する。</p>

<h2>```yaml</h2>

<ul>
<li>name: add the user &ldquo;guest&rdquo;
user: name=guest shell=/bin/bash password=
become: yes
become_method: sudo
```</li>
</ul>


<p><code>name</code> は任意。タスク内容をコメントとして記述する。</p>

<p><code>user</code> がモジュール名、それに続いて各モジュールのオプション。</p>

<p><code>become</code>, <code>become_method</code> で管理ノードで sudo を使って実行することを許可している。</p>

<h1>2. ansible 実行</h1>

<p>クライアント側で事前にユーザの確認。
guest ユーザは存在しない。</p>

<p><code>sh
managed_node$ grep guest /etc/passwd
</code></p>

<p>まずは、<code>--check</code> オプションを付けてテスト実行(dry run)。実際の構成変更はせず、
Playbook のシンタックスチェックなどを実施する。</p>

<p>```sh
controller$ ansible-playbook -i centos/hosts centos/site.yml -K &mdash;check
SUDO password:</p>

<p>PLAY ***************************************************************************</p>

<p>TASK [setup] *******************************************************************
ok: [192.168.11.14]</p>

<p>TASK [../common/guest_account : add the user &ldquo;guest&rdquo;] **************************
changed: [192.168.11.14]</p>

<p>PLAY RECAP *********************************************************************
192.168.11.14              : ok=1    changed=1    unreachable=0    failed=0</p>

<p>```</p>

<p>問題ないようなので実行してみる。</p>

<p>```sh
controller$ ansible-playbook -i centos/hosts centos/site.yml -K
SUDO password:</p>

<p>PLAY ***************************************************************************</p>

<p>TASK [setup] *******************************************************************
ok: [192.168.11.14]</p>

<p>TASK [../common/guest_account : add the user &ldquo;guest&rdquo;] **************************
changed: [192.168.11.14]</p>

<p>PLAY RECAP *********************************************************************
192.168.11.14              : ok=2    changed=2    unreachable=0    failed=0 <br/>
```</p>

<p>クライアント側で事後確認してみると、ユーザができている。</p>

<p><code>sh
managed_node$ grep guest /etc/passwd
guest:x:1001:1001::/home/guest:/bin/bash
</code></p>

<h1>3. 他にもいろいろとインストールする</h1>

<p>ruby や zsh などもインストールする。
インストール対象のプロダクト毎に role を作っている。</p>

<p>role の粒度がいまいちどれくらいにしたらよいのかが分からない。</p>

<p>たとえば、ruby role には ruby のインストールだけにとどめておくべきか、
rbenv のような関連ツールまで 1 セットで記述するのが良いか。</p>

<p>まあ、使いながらやりやすい粒度を模索する、でも良いと思う。</p>

<p>また、OS 毎の差異を吸収するため、<code>common/role/HOGE/tasks/</code> 以下に <code>main.yml</code>を置いて、
それぞれのOS毎のymlをインクルードした。
ただ、<code>centos/</code>的な大本からディレクトリを分けて、<code>main.yml</code>でOS判定と
条件分岐しないような配置でも良かったかもなとも思っている。</p>

<p>以下のようなディレクトリ構成となった。</p>

<p><code>``sh
controller$ tree laptop_build
laptop_build
|-- centos
|   |-- hosts
|  </code>&mdash; site.yml
|&mdash; common
|   |&mdash; dotfiles
|   |   |&mdash; meta
|   |   |   <code>-- main.yml
|   |  </code>&mdash; tasks
|   |       <code>-- main.yml
|   |-- guest_account
|   |  </code>&mdash; tasks
|   |       <code>-- main.yml
|   |-- ruby
|   |   |-- meta
|   |   |  </code>&mdash; main.yml
|   |   <code>-- tasks
|   |      </code>&mdash; main.yml
|   |&mdash; tmux
|   |   <code>-- tasks
|   |       |-- centos.yml
|   |       |-- main.yml
|   |      </code>&mdash; ubuntu.yml
|   |&mdash; vim
|   |   <code>-- tasks
|   |      </code>&mdash; main.yml
|   <code>-- zsh
|      </code>&mdash; tasks
|           |&mdash; centos.yml
|           |&mdash; main.yml
|           <code>-- ubuntu.yml
|-- private_vars
|  </code>&mdash; common.yml
`&mdash; vars</p>

<pre><code>`-- common.yml
</code></pre>

<p>```</p>

<p>公式ドキュメントを見つつ、yum や git モジュールを利用した。</p>

<p>中身の説明は、体力が切れたので割愛。
詳細は、<a href="https://github.com/momota/laptop-build">momota/laptop-build</a> を参照。</p>
]]></content>
  </entry>
  
</feed>
