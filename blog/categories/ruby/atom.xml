<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | momota.txt]]></title>
  <link href="http://momota.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://momota.github.io/"/>
  <updated>2016-05-30T11:06:56+09:00</updated>
  <id>http://momota.github.io/</id>
  <author>
    <name><![CDATA[momota]]></name>
    <email><![CDATA[makoto.momota@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[seleniumノウハウ]]></title>
    <link href="http://momota.github.io/blog/2016/05/28/selenium-know-how/"/>
    <updated>2016-05-28T16:57:00+09:00</updated>
    <id>http://momota.github.io/blog/2016/05/28/selenium-know-how</id>
    <content type="html"><![CDATA[<p><a href="http://momota.github.io/blog/2016/02/26/selenium/">ブラウザ操作の自動化: Selenium と Ruby</a> でも書いたが、
selenium が便利すぎて、最近よくスクリプトを書くようになった。</p>

<p>以下のようなノウハウが溜まってきたので、ここらで放出する。</p>

<ul>
<li>ウィンドウサイズのリサイズ</li>
<li>ウィンドウ位置の移動</li>
<li>スクリーンショットの取得</li>
<li>要素セレクタメソッドの使い分け</li>
<li>ドロップダウンリストの選択</li>
<li>マウスオーバ (hover)</li>
<li>フレーム移動</li>
<li>コード量を減らすためのモンキーパッチ</li>
</ul>


<!-- more -->


<h2>ウィンドウサイズのリサイズ</h2>

<p><code>driver.manage.window.resize_to</code>の引数にリサイズするサイズ情報(width, height)を渡す。</p>

<p>```ruby
require &ldquo;selenium-webdriver&rdquo;</p>

<p>width  = 100
height = 100</p>

<p>driver = Selenium::WebDriver.for :firefox
driver.manage.window.resize_to(width, height)
```</p>

<p>現在のサイズを取得して、相対的にリサイズしたい場合は以下のようにする。</p>

<p>```ruby
require &ldquo;selenium-webdriver&rdquo;</p>

<p>driver = Selenium::WebDriver.for :firefox</p>

<p>size = driver.manage.window.size
size.width  += 100
size.height += 100
driver.manage.window.size = size
```</p>

<h2>ウィンドウ位置の移動</h2>

<p><code>driver.manage.window.move_to</code>の引数に移動したい場所の座標情報(x, y)を渡す。</p>

<p>```ruby
require &ldquo;selenium-webdriver&rdquo;</p>

<p>x = 100
y = 100</p>

<p>driver = Selenium::WebDriver.for :firefox
driver.manage.window.move_to(x, y)
```</p>

<p>現在のウィンドウ位置を取得して、相対的にリサイズしたい場合は以下のようにする。</p>

<p>```ruby
require &ldquo;selenium-webdriver&rdquo;</p>

<p>driver = Selenium::WebDriver.for :firefox</p>

<p>pos = driver.manage.window.position
pos.x += 100
pos.y += 100
driver.manage.window.position = pos
```</p>

<h2>スクリーンショットの取得</h2>

<p>開いているページのスクリーンショットを撮りたい場合は、<code>driver.save_screenshot</code> に保存先のファイル名を指定するだけ。</p>

<p>```ruby
require &ldquo;selenium-webdriver&rdquo;</p>

<p>driver = Selenium::WebDriver.for :firefox
driver.get(&ldquo;<a href="https://www.google.co.jp/">https://www.google.co.jp/</a>&rdquo;)
driver.save_screenshot(&ldquo;/path/to/save/screenshot.png&rdquo;)
```</p>

<p>ページ全体を撮りたいのに、frame 構造が邪魔をして、スクロールしなければ全体が撮れない場合がある。
ちょっと、調べたところ <code>driver.execute_script("some script")</code> で javascript を利用してスクロールをしている人がいたり、
<code>Selenium::WebDriver::Element.location_once_scrolled_into_view</code> を使ってスクロールしている人がいたり。
どちらにしても、コンテンツ表示上の高さを取得して、1スクロール分の長さをデクリメントしていっているような処理。</p>

<p>自分の場合は、めんどくさかったので、上述したリサイズ方法を使ってスクロールがいらないくらいウィンドウサイズを大きくして、
スクリーンショットを撮るという荒業を繰り広げている。</p>

<h2>要素セレクタメソッドの使い分け</h2>

<p>要素セレクタメソッドは <code>find_element</code> と <code>find_elements</code> の2種類。
そのメソッド名の単数形・複数形の通りなのだが、以下のような違いがある</p>

<ul>
<li><code>find_element</code>

<ul>
<li>指定した引数にマッチする最初の要素を <strong>1つ</strong> 返す。(<code>WebDriver::Element</code>)</li>
<li>マッチする要素がなければ例外を投げる。(<code>NoSuchElementError</code>)</li>
</ul>
</li>
<li><code>find_elements</code>

<ul>
<li>指定した引数にマッチする要素を詰めた配列を返す。(<code>Array&lt;WebDriver::Element&gt;</code>)</li>
<li>マッチする要素がなければ、空の配列を返す。(<code>Array&lt;WebDriver::Element&gt;</code>)</li>
</ul>
</li>
</ul>


<p>テーブルの <code>&lt;tr&gt;</code> 要素やリストの <code>&lt;li&gt;</code> 要素に対してイテレーション処理するときには <code>find_elements</code> が便利。</p>

<p>```ruby</p>

<h1>リストのリンクをクリックしていくイテレーション</h1>

<p>elements = d.find_elements(:css, &ldquo;#some-list > li&rdquo;)
elements.each { |e|
  link = e.find_element(:tag_name, &ldquo;a&rdquo;)
  link.click
}
```</p>

<p>要素セレクタメソッドの引数は、<code>find_element(:how, "what")</code> のように symbol と文字列を渡す。
<code>find_elements</code> も同じ。</p>

<p>指定できるsymbolの種類は以下。</p>

<table>
<thead>
<tr>
<th>symbol             </th>
<th> 対象</th>
</tr>
</thead>
<tbody>
<tr>
<td>:class             </td>
<td> クラス名 (属性名 class)</td>
</tr>
<tr>
<td>:class_name        </td>
<td> 上記 :class と同じ</td>
</tr>
<tr>
<td>:id                </td>
<td> ID (属性名 id)</td>
</tr>
<tr>
<td>:link_text         </td>
<td> <code>&lt;a&gt;</code> タグのテキスト</td>
</tr>
<tr>
<td>:link              </td>
<td> 上記 :link_text と同じ</td>
</tr>
<tr>
<td>:partial_link_text </td>
<td> <code>&lt;a&gt;</code> タグのテキストの部分文字列</td>
</tr>
<tr>
<td>:name              </td>
<td> name (属性名 name)</td>
</tr>
<tr>
<td>:tag_name          </td>
<td> タグ名</td>
</tr>
<tr>
<td>:xpath             </td>
<td> xpath で指定</td>
</tr>
<tr>
<td>:css               </td>
<td> css セレクタ で指定</td>
</tr>
</tbody>
</table>


<p><a href="http://www.rubydoc.info/gems/selenium-webdriver/0.0.28/Selenium/WebDriver/Find#find_element-instance_method">参考</a></p>

<h2>ドロップダウンリストの選択</h2>

<p>Selenium IDEでRubyコードの出力をしようとすると、ドロップダウンリストの部分がERRORになって
コメントアウトされることがある。(今のバージョンは大丈夫そう)
以下のように、書き換えればOK。</p>

<p>```ruby
s = Selenium::WebDriver::Support::Select.new(driver.find_element(:tag_name, &ldquo;select&rdquo;))
s.select_by(:text, &ldquo;ほげほげ&rdquo;)  # 表示テキストで選択
s.select_by(:value, &ldquo;value1&rdquo;)   # valueの値で選択
s.select_by(:index, 0)          # index(0, 1, 2, &hellip;)で選択</p>

<p>```</p>

<h2>マウスオーバ (hover)</h2>

<p>例えば、ナビゲーションメニューなどが、通常時には折りたたまれていて、メニュー上にマウスオーバした場合に、
子メニューが展開されるようなページがある。
折りたたまれているときに、子メニューHTMLをロードできていないようなページのときは、ユーザ操作と同じように
マウスオーバしてあげる必要がある。</p>

<p>以下のようにマウスオーバしたい要素を指定して、<code>driver.mouse.move_to</code> を呼べば良い。</p>

<p><code>ruby
e = driver.find_element(:id, "menu")
driver.mouse.move_to( e )
</code></p>

<h2>フレーム移動</h2>

<p>frame や iframe 要素を使っているサイトで、そのフレーム内の要素に対して操作したい場合、当該フレームへ切り替える操作が必要となる。</p>

<p>以下のようにスイッチしたいフレーム要素を指定して、<code>driver.switch_to.frame</code> を呼べば良い。</p>

<p><code>ruby
frame = driver.find_element(:id, "frame")
driver.switch_to.frame( frame )
</code></p>

<h2>コード量を減らすためのモンキーパッチ</h2>

<p>たとえば、ログインなどの処理の際、フォームへ文字列を送る <code>send_keys</code> 前にいつも <code>.clear</code> しているので
もう <code>send_keys</code> の中に <code>.clear</code> 処理を入れ込んでしまえと思った。</p>

<p>また、<code>input</code> タグの値を取得するときは、<code>.attribute("value")</code> と長ったらしく書く必要があるので <code>.value</code>メソッドを
定義してしまおうと思った。</p>

<p>そこで、以下のようなモンキーパッチを書く。</p>

<p>```ruby
module ElementExtension
  refine Selenium::WebDriver::Element do</p>

<pre><code>def send_keys( str )
  self.clear
  super( str )
end

def value
  self.attribute("value")
end
</code></pre>

<p>  end
end</p>

<p>using ElementExtension
```</p>

<p>そうすると以下のようにコード量を減らせる。</p>

<p>```diff</p>

<h1>たとえば、ログイン処理</h1>

<p>user     = &ldquo;USER&rdquo;
password = &ldquo;PASSWORD&rdquo;</p>

<ul>
<li>driver.find_element(:id, &ldquo;loginuser&rdquo;).clear
driver.find_element(:id, &ldquo;loginuser&rdquo;).send_keys( user )</li>
<li>driver.find_element(:id, &ldquo;loginpass&rdquo;).clear
driver.find_element(:id, &ldquo;loginpass&rdquo;).send_keys( password )
driver.find_element(:id, &ldquo;submit&rdquo;).click</li>
</ul>


<h1><input>の値を取得する処理</h1>

<ul>
<li>hostname = driver.find_element(:id, &ldquo;hostname&rdquo;).attribute(&ldquo;value&rdquo;)</li>
<li>hostname = driver.find_element(:id, &ldquo;hostname&rdquo;).value
```</li>
</ul>


<p>モンキーパッチの書き方は以下を参考にした。</p>

<ul>
<li><a href="http://melborne.github.io/2013/08/30/monkey-patching-for-prudent-rubyists/">分別のあるRubyモンキーパッチャーになるために</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ブラウザ操作の自動化: selenium と ruby]]></title>
    <link href="http://momota.github.io/blog/2016/02/26/selenium/"/>
    <updated>2016-02-26T10:41:00+09:00</updated>
    <id>http://momota.github.io/blog/2016/02/26/selenium</id>
    <content type="html"><![CDATA[<p>selenium と ruby を使ってブラウザ GUI 操作を自動化する。</p>

<p><a href="http://www.seleniumhq.org/">selenium</a> は、Web アプリケーションの自動テストのためのツール。
レグレッションテストによく使われているようだ。</p>

<p>selenium は、ブラウザ操作シナリオを事前に設定して、シナリオ通りに実行してくれる。
シナリオ設定といっても、Firefoxプラグインの Selenium IDE などを使うと操作を
記録してくれる機能があるのでそこまで大変ではない。
詳細は、<a href="http://www.ruby.or.jp/ja/tech/development_tool/reg_test/">Ruby アソシエーション &ndash; selenium</a> の &ldquo;1.2 テストの作成&rdquo;
あたりを参照してほしい</p>

<p>selenium は、クロスブラウザのツールで、IE を使って IE限定みたいなサイトでも使える。
IE や Chrome で使うには各 Selenium WebDriver が必要となる。</p>

<p>テスト用と言いつつ、使い道はいろいろとある。</p>

<ul>
<li>社内のもろもろの web 申請は、入力項目が多いのに、毎回ほぼ同じ内容を入力させるので
フォーム入力の省力化として利用している。</li>
<li>hp さんの iLO や日立さんストレージ、F5 さんのBIG-IP みたいな web 画面から設定変更するような機器の
自動構築なんかもできそう。

<ul>
<li>スクリーンショットも撮れるので、エビデンスもついでに取得可能。</li>
<li>vCenter とかも操作できないかという思惑はある。</li>
<li>AWS とかも操作できるけど、そもそも API が豊富に備わっているから不要か。</li>
</ul>
</li>
<li>あえて selenium を使わなくてもいいけど、クローリングやスクレイピングとかもできる</li>
</ul>


<p>この selenium は、Java や Python, Ruby などのプログラミング言語からシナリオ操作が可能で
ループ処理などするにはめちゃくちゃ便利。</p>

<p>いままでは Firefox プラグインだけで利用していたが、Ruby と絡めると便利すぎて感謝しかなかった。
ここでは、サンプルとして、はてなブックマークのホットエントリトップ5を一括で開くことを
やってみたい。</p>

<p>ちなみに似たツールに iMacro がある。</p>

<p>関連記事: <a href="http://momota.github.io/blog/2016/05/28/selenium-know-how/">seleniumノウハウ</a></p>

<!-- more -->


<p>環境は、以下。</p>

<table>
<thead>
<tr>
<th>モノ         </th>
<th> バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td>OS           </td>
<td> Windows 8.1 Pro</td>
</tr>
<tr>
<td>ブラウザ     </td>
<td> Firefox ESR 38.6.1</td>
</tr>
<tr>
<td>Selenium IDE </td>
<td> 2.9.0</td>
</tr>
<tr>
<td>Ruby         </td>
<td> 2.2.4p230 (2015-12-16 revision 53155) [x64-mingw32]</td>
</tr>
<tr>
<td>gem          </td>
<td> selenium-webdriver (2.52.0)</td>
</tr>
</tbody>
</table>


<h1>準備</h1>

<p>Windows に Rubyをインストールする。</p>

<p><a href="http://rubyinstaller.org/downloads/">RubyInstaller</a> の RubyInstallers からインストーラをダウンロードし、実行する。
インストール時、 PATH を通すチェックボックスにチェックを入れる。</p>

<p>続いてDevelopment Kitをインストールする。<a href="http://www.rubylife.jp/railsinstall/rails/index4.html">この辺を参考に。</a>
これも RubyInstaller の Development Kit からダウンロードして、解凍する。
解答したファイルに <code>dk.rb</code> があるのでコマンドプロンプトから以下のように実行する。</p>

<p>```sh</p>

<blockquote><p>cd {DEVELOPMENT KIT の解凍ディレクトリ}
ruby dk.rb init
ruby dk.rb install
```</p></blockquote>

<p>次に、<code>selenium-webdriver</code> をインストールする。
Ruby をインストールしたことで、一緒に gem も使えるようになっているはずなので、
コマンドプロンプトから以下を打鍵。</p>

<p>```sh</p>

<blockquote><p>gem install selenium-webdriver
```</p></blockquote>

<p>インストールの確認。irb (もしくは pry) とかで require できることを確認する。</p>

<p>```sh</p>

<blockquote><p>irb
irb(main):001:0> require &ldquo;selenium-webdriver&rdquo;
=> true
```</p></blockquote>

<h1>はてなホットエントリのトップ5エントリーを開く</h1>

<p>ここではサンプルとして、はてなブックマークのホットエントリからトップ5 をブラウザで
次々に開くよう <code>hatena.rb</code> を書く。</p>

<p>```ruby
require &ldquo;selenium-webdriver&rdquo;</p>

<p>class Hatena
  def initialize</p>

<pre><code># ブラウザの起動
@driver = Selenium::WebDriver.for :firefox

# ベース URL
@base_url = "http://b.hatena.ne.jp"
</code></pre>

<p>  end</p>

<p>  def open_top5</p>

<pre><code># ベースURL を開く
@driver.get(@base_url + "/hotentry")

# CSS セレクタで要素を特定してクリックする
5.times { |i|
  @driver.find_element(:css, "a[data-entryrank='#{i + 1}']").click
  sleep 1
}
</code></pre>

<p>  end
end</p>

<p>if <strong>FILE</strong> == $0
  hatena = Hatena.new
  hatena.open_top5
end
```</p>

<p>コマンドプロンプトからこのスクリプトを実行すると次々とブラウザが起動してくる。
```sh</p>

<blockquote><p>ruby hatena.rb
```</p></blockquote>

<p>こんな感じ。</p>

<p><img src="/images/20160226_selenium.gif" alt="hatena_screenshot" /></p>

<p><code>find_element</code> メソッドは、CSSセレクタやxpath、タグ名、タグのID、class名などを指定できる。</p>

<p>フォームになにか値を突っ込みたいときは、<code>@driver.find_element(~~~~~).send_keys "VALUE"</code> みたいな感じで
要素を特定したあと、<code>send_keys</code> で文字列を渡してあげればよい。
POST は、ボタンを find_element してあげて<code>.click</code> (<code>.submit</code> でも良さ気) でOK。</p>

<p>スクリーンショットを撮るときは、<code>@driver.save_screenshot "./screenshot.png"</code> みたいな感じ。</p>

<h1>参考</h1>

<ul>
<li><a href="http://www.ruby.or.jp/ja/tech/development_tool/reg_test/">Ruby アソシエーション &ndash; selenium</a></li>
<li><a href="http://qiita.com/kkakizaki/items/5a0e6f753193f2a1514f">Selenium 入門 &ndash; Qiita</a></li>
<li>関連記事: <a href="http://momota.github.io/blog/2016/05/28/selenium-know-how/">seleniumノウハウ</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lita で Slack Bot (on heroku) をつくる]]></title>
    <link href="http://momota.github.io/blog/2015/01/11/lita/"/>
    <updated>2015-01-11T21:36:00+09:00</updated>
    <id>http://momota.github.io/blog/2015/01/11/lita</id>
    <content type="html"><![CDATA[<p><img src="https://www.lita.io/assets/lita-94f070fbb79e8ec62cc7a21ca39f8448.png" alt="lita" /></p>

<p>チャットツール <a href="https://slack.com/">slack</a> に常駐する bot をつくったので、そのときの導入メモ。
bot 開発には <a href="https://www.lita.io/">lita</a> を利用した。lita は Ruby で書かれた chat bot フレームワーク。hubot にインスパイアされて開発されたようだ。
js (coffee script) よりも ruby のほうがとっつきやすかったので採用した。</p>

<p>環境は、ubuntu 14.04, ruby 2.1.5, lita 4.0.4.</p>

<p>ゆくゆくは、<a href="http://www.amazon.co.jp/gp/product/B00H91KK26/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00H91KK26&amp;linkCode=as2&amp;tag=mmtmkt-22">iRKit</a> とか使って家電と連携したりしたい。</p>

<!-- more  -->


<p><img src="https://dl.dropboxusercontent.com/u/28495046/octopress/20150111_lita/lita.png" alt="network" /></p>

<p>今回の構成図を上記に示す。</p>

<h2>1. 事前準備: もろもろインストールする</h2>

<h3>1.1 lita をインストール</h3>

<p>lita は gem でインストールできる。</p>

<p><code>sh
$ gem install lita
</code></p>

<h3>1.2 redis をインストール</h3>

<p>lita はデータ永続化ストレージとして redis を使うことが前提となっている。
つまり、ローカル環境で lita を実行するには(開発するには)、redis が必要なため、redis をインストールする。</p>

<p><code>sh
$ sudo apt-get update
$ sudo apt-get install redis-server
</code></p>

<p>redis を起動する。</p>

<p>```sh
$ sudo service redis-server start
$ sudo service redis-server status</p>

<h1>=> redis の起動状態確認</h1>

<h1>=> ps aux | grep redis とかで確認してもいい</h1>

<p>```</p>

<h2>2. lita プロジェクト作成、起動</h2>

<p>lita プロジェクト"sample"を作成する。</p>

<p>```sh
$ lita new sample</p>

<h1>=> sample ディレクトリが生成される</h1>

<p>$ cd sample
```</p>

<p>ruby のバージョンを rbenv で指定しておく。</p>

<p><code>sh
$ rbenv local 2.1.5
$ rbenv rehash
$ ruby -v
</code></p>

<p>bundler でインストールする。</p>

<p><code>
$ bundle install --path vendor/bundle
</code></p>

<p><code>lita start</code> で lita をローカル環境で起動してみる。
<code>lita help</code> で返ってくればOK。</p>

<p><code>sh
$ bundle exec lita start
Type "exit" or "quit" to end the session.
Lita &gt; lita info
Lita 4.0.4 - https://www.lita.io/
Redis 2.8.4 - Memory used: 414.04K
Lita &gt; lita help
Lita: help - Lists help information for terms and command the robot will respond to.
Lita: help COMMAND - Lists help information for terms or commands that begin with COMMAND.
Lita: info - Replies with the current version of Lita.
Lita &gt; exit
$
</code></p>

<p><a href="https://www.lita.io/plugins">lita プラグイン</a> もたくさんあるので、適当に <code>Gemfile</code> に追加して <code>bundle install</code> するとよい。</p>

<h2>3. herokuへデプロイして Slack と連携する</h2>

<p>lita bot を heroku へデプロイする。
また、アダプタ <a href="https://github.com/kenjij/lita-slack">lita-slack</a> を利用して Slack と連携する。</p>

<h3>3.1 事前準備</h3>

<p>heroku へのデプロイは、git push して行うので、git でバージョン管理を開始する。</p>

<p><code>sh
$ git init
$ git add .
$ git commit -m "first commit"
</code></p>

<p>heroku で ruby バージョンを指定するには、<code>Gemfile</code>で<code>ruby "VERSION"</code>と記述する。
また、Slack と連携するため、<code>lita-slack</code> アダプタもインストールする。
この時点で、<code>Gemfile</code>は以下の通り。</p>

<p>```ruby
source &ldquo;<a href="https://rubygems.org">https://rubygems.org</a>&rdquo;
ruby &ldquo;2.1.5&rdquo;</p>

<p>gem &ldquo;lita&rdquo;
gem &ldquo;lita-slack&rdquo;
```</p>

<p>bundler でインストールする。</p>

<p><code>sh
$ bundle install --path vendor/bundle
</code></p>

<p>slack とつなげたり、Redis To Go を利用するために、<code>lita_config.rb</code> を以下のように修正する。</p>

<p>```ruby
Lita.configure do |config|
  config.robot.name      = &ldquo;lita&rdquo;
  config.robot.log_level = :info</p>

<p>  # アダプタの指定。Slack とつなげるので、:slack と修正する
  config.robot.adapter   = :slack</p>

<p>  # Slack のAPIキーを指定する
  # 後述する heoku コマンドで heroku の環境変数を設定する
  config.adapters.slack.token = ENV[&ldquo;SLACK_API_KEY&rdquo;]</p>

<p>  # heroku の redis アドオン Redis To Go 関連の設定
  config.redis[:url] = ENV[&ldquo;REDISTOGO_URL&rdquo;]
  config.http.port   = ENV[&ldquo;PORT&rdquo;]
end
```</p>

<p>heroku でのアプリケーション起動には foreman でのアプリケーション起動が必要となる。
以下の <code>Procfile</code> を作成する。</p>

<p><code>ruby
web: bundle exec lita
</code></p>

<h3>3.2 heroku の設定</h3>

<p>新規に heroku アプリケーションを作成する。
ここでは、<code>lita-sample</code> という名前にした。</p>

<p><code>sh
$ heroku apps:create lita-sample
</code></p>

<p>heroku の redis アドオン Redis To Go をアプリケーションへ追加する。
事前に heroku へクレジットカードの登録が必要。</p>

<p><code>sh
$ heroku addons:add redistogo --app lita-sample
</code></p>

<p>heroku の環境変数を設定する。
設定するのは、Slack APIキーのみでOK。
Slack API キーは、<a href="https://YOUR-DOMAIN.slack.com/services/new/lita">https://YOUR-DOMAIN.slack.com/services/new/lita</a> から Integration の設定をしたら入手可能。</p>

<p><code>REDISTOGO_URL</code> などは、アドオン追加時に自動で設定されている。</p>

<p>```sh
$ heroku config:set SLACK_API_KEY=&ldquo;your-slack-api-key&rdquo;
$ heroku config</p>

<h1>=> heroku 上で設定されている環境変数が出力されるので正しく設定されているか確認する</h1>

<p>```</p>

<h3>3.3 heroku へデプロイする</h3>

<p>git commit して git push してあげる。
そうすると heoku アプリケーションが起動する。</p>

<p><code>sh
$ git commit -m "make it better"
$ git push heroku master
</code></p>

<p>Slack に lita さんが見えるはずなので 適当なチャンネルに招待して <code>@lita help</code> とか声をかけると答えてくれる。</p>

<h3>3.4 heroku アプリケーションをたたき起こす</h3>

<p>heroku を無料で使う 1 web dyno (webサーバインスタンス) のときは、1時間アクセスがないとアプリケーションがスリープする。つまり、せっかくデプロイした bot も眠ってしまうため、定期的にhttpアクセスさせてたたき起こしておく。
なお、<code>lita-cron</code> で bot に定期的に投稿させてもだめだったので、heroku アプリケーションへの http アクセスが必要なもよう。</p>

<p>定期的な http アクセスには <a href="http://uptimerobot.com/">Uptime Robot</a> を利用した。</p>

<h2>4. handler 作成</h2>

<p>以下のように handler のひな形を生成する。
<code>lita-</code> というプレフィックスが自動で付与される。</p>

<p>```sh
$ mkdir handlers
$ cd handlers
$ bundle exec lita hello_handler</p>

<h1>=> lita-hello_handler ディレクトリが生成される</h1>

<p>```</p>

<p><code>handlers/lita-hello_handler/lib/lita/handlers/hello_hundler.rb</code> を修正する。
<code>route</code> で正規表現にマッチした場合の処理へルーティングする。</p>

<p>```ruby
module Lita
  module Handlers</p>

<pre><code>class HelloHandler &lt; Handler
  route /^java\s+(.+)/, :with_java, help: { "java TEXT" =&gt; "reply back with java." }

  def with_java( response )
    word = response.matches[0][0]
    response.reply("!!! #{word} とジャバ !!!")
  end
end

Lita.register_handler(HelloHandler)
</code></pre>

<p>  end
end
```</p>

<p><code>Gemfile</code> に以下を追記し、 <code>bundle install</code> する。</p>

<p><code>ruby
gem "lita-hello_handler", path: "handlers/lita-hello_handler"
</code></p>

<p>commit して再度 heroku へ push してデプロイする。</p>

<p><code>sh
$ git commit -a -m "make it better"
$ git push heroku master
</code></p>

<p>slack 上で <code>@lita java あなた</code> とかつぶやくとサイコーにジャバな気分になる。</p>

<p><img src="https://dl.dropboxusercontent.com/u/28495046/octopress/20150111_lita/slack_lita.png" alt="lita java" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails じゃなくても ActiveRecord を使う]]></title>
    <link href="http://momota.github.io/blog/2014/05/10/activerecord/"/>
    <updated>2014-05-10T14:54:00+09:00</updated>
    <id>http://momota.github.io/blog/2014/05/10/activerecord</id>
    <content type="html"><![CDATA[<p>rails には挫折したおれが、rails アプリケーション以外で ActiveRecord を使うようになった件について。</p>

<p>ActiveRecord は O/Rマッパーで RDB のテーブルエントリをオブジェクトとして扱えるようにするやつ。1インスタンスが、テーブルの1レコードに相当する。
Ruby on Rails 標準で、モデル層で使われる。</p>

<p>環境は以下。</p>

<ul>
<li>Mac OSX</li>
<li>ruby 2.1.1p76</li>
<li>MySQL mysqld5.6.17</li>
</ul>


<p>最終的なディレクトリ構成は以下のようになる。</p>

<p>```sh
.
├── Gemfile
├── Gemfile.lock
├── README.md
├── Rakefile
├── app
│   └── models
│       └── hoges.rb
├── app.rb
├── config
│   └── database.yml
├── db
│   └── migrate
│       └── 20140510_create_hoges.rb
├── log
│   ├── database.log
│   └── trace.log
└── vendor</p>

<pre><code>└── bundle
        └── (略)
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/momota/activerecord_sample">https://github.com/momota/activerecord_sample</a></li>
</ul>


<!-- more -->


<h2>前準備</h2>

<h3>ruby</h3>

<p>rbenv で ruby 2.1.1 をインストールする。</p>

<p><code>sh
$ rbenv install 2.1.1
$ rbenv local 2.1.1
$ rbenv rehash
$ ruby -v
ruby 2.1.1p76 (2014-02-24 revision 45161) [x86_64-darwin13.0]
</code></p>

<h3>gem</h3>

<p>bundler で gem をインストールする。
まず、bundler をインストールする。</p>

<p><code>sh
$ gem install bundle
$ bundle -v
Bundler version 1.6.2
</code></p>

<p>以下の <code>Gemfile</code> をつくって<code>bundle install --path vendor/bundle</code> して gem をインストールする。</p>

<p>```ruby
source &ldquo;<a href="https://rubygems.org">https://rubygems.org</a>&rdquo;</p>

<p>gem &ldquo;activerecord&rdquo;
gem &ldquo;rake&rdquo;
gem &ldquo;mysql2&rdquo;
gem &ldquo;pry&rdquo;
```</p>

<p><code>mysql2</code> はDBアダプタ。MySQLと接続するために必要。</p>

<p><code>pry</code> はなくてもよい。<code>irb</code> の便利バージョン。</p>

<h3>mysql</h3>

<p>homebrew でインストールした。</p>

<p><code>my.cnf</code>はよしなに。</p>

<p><code>create database</code> とか <code>grant</code> でユーザやデータベースなどはあらかじめ作っておく。</p>

<h2>create table: rake タスクを使ってテーブルを作成する</h2>

<p><code>rake</code> (makeみたいなもん) でテーブルを作成する。(マイグレーション)</p>

<p>マイグレーションは、SQLを使わずにデータベースのテーブルやカラムなどの構造を変更できる仕組みで、移行と解釈するとややこしい。データベース移行をしやすくする仕組み、くらいに捉えておくとよい。</p>

<h3>マイグレーション用ファイルを作成する</h3>

<p><code>db/migrate</code> ディレクトリを作ってマイグレーション用ファイルを作る。</p>

<p>ここでは hoges テーブルを作ることにする。
マイグレーション用ファイルには、テーブル定義を書く。ここでは <code>db/migrate/20140510_create_hoges.rb</code> を作成する。</p>

<p>このファイル名が大事で <code>20140510</code> の部分がバージョンとして管理される。<code>schema_migrations</code> テーブルが自動生成され、そこで管理される。また、マイグレーション用ファイル中に class 名を<code>CreateHoges</code> のようにキャメルケースで定義した場合は、ファイル名は <code>VERSION_create_hoge.rb</code> のようにスネークケースとして命名する必要がある。ファイル名がこの命名規約に反するとマイグレーションがこける。</p>

<p>rails文化の「設定より規約」(CoC: Convention over Configuration)ってやつですね。</p>

<p><code>ActiveRecord::Migration</code> を継承したクラス <code>Createhoges</code> を定義する。
シンボル <code>:hoges</code> がテーブル名。カラム定義は見ての通りだと思う。
主キーは自動的に <code>id</code> というカラム名で生成されるので書かない。(書くとエラーになる)</p>

<p>```ruby
class CreateHoges &lt; ActiveRecord::Migration
  def self.up</p>

<pre><code>create_table :hoges do |t|
  t.string  :name
  t.string  :url
  t.timestamps  # =&gt; これでcreated_atとupdated_atカラムが定義される
end
</code></pre>

<p>  end</p>

<p>  def self.down</p>

<pre><code>drop_table :hoges
</code></pre>

<p>  end
end
```</p>

<p>書き方の詳細は、<a href="http://guides.rubyonrails.org/migrations.html">Active Record Migrations</a> を見れば良いと思う。</p>

<h3>データベース接続情報を yaml に書き出す</h3>

<p>MySQL への接続情報(DBユーザ名とかパスワードとか使うDB名とか)を yaml ファイルに書き出しておく。めんどくさい、かつ、使い捨てのコードならハードコーディングしといてもOK。</p>

<p>ここでは、以下の内容で <code>config/database.yml</code> を作成した。</p>

<p>```erb
db:
  production:</p>

<pre><code>adapter:  mysql2
host:     localhost
username: &lt;%= ENV['DATABASE_USERNAME'] %&gt;
password: &lt;%= ENV['DATABASE_PASSWORD'] %&gt;
database: &lt;%= ENV['DATABASE_NAME']%&gt;
</code></pre>

<p>  development:</p>

<pre><code>adapter:  mysql2
host:     localhost
username: &lt;%= ENV['DEV_DATABASE_USERNAME'] %&gt;
password: &lt;%= ENV['DEV_DATABASE_PASSWORD'] %&gt;
database: &lt;%= ENV['DEV_DATABASE_NAME']%&gt;
</code></pre>

<p>```</p>

<p>パスワードなどの秘匿情報は環境変数から読み込むようにする。(ここではERB形式で書いた)
パスワードをべた書きしといて、間違えて github とかで公開しちゃうと大変なので。</p>

<p><code>~/.zshrc</code> とか <code>~/.bashrc</code> にあらかじめ作っておいたデータベース名とかユーザ名を以下のように足して <code>source ~/.zshrc</code> で読み込めばいいと思う。</p>

<p><code>sh
export DEV_DATABASE_NAME="hoge_db"
export DEV_DATABASE_USERNAME="hoge_user"
export DEV_DATABASE_PASSWORD="hoge_password"
</code></p>

<h3>Rakefile をつくって rakeタスクを実行する</h3>

<p>以下の内容で <code>Rakefile</code> を作る。
DB接続用の設定や環境指定(development/production) やバージョン指定の設定を書いてます。</p>

<p>```ruby
require &ldquo;active_record&rdquo;
require &ldquo;yaml&rdquo;
require &ldquo;erb&rdquo;
require &ldquo;logger&rdquo;</p>

<p>task :default => :migrate</p>

<p>desc &ldquo;Migrate database&rdquo;
task :migrate => :environment do
  ActiveRecord::Migrator.migrate(&lsquo;db/migrate&rsquo;, ENV[&ldquo;VERSION&rdquo;] ? ENV[&ldquo;VERSION&rdquo;].to_i : nil)
end</p>

<p>task :environment do
  db_conf = YAML.load( ERB.new( File.read(&ldquo;./config/database.yml&rdquo;) ).result )</p>

<p>  # <code>rake ENV=development</code>/<code>rake ENV=production</code>で切り替え可能
  ActiveRecord::Base.establish_connection( db_conf[&ldquo;db&rdquo;][ENV[&ldquo;ENV&rdquo;]] )
  ActiveRecord::Base.logger = Logger.new(&ldquo;log/database.log&rdquo;)
end
```</p>

<p>以下を参考。</p>

<ul>
<li><a href="http://qiita.com/foloinfo/items/6ecfe3c5fd1b56f1dceb">非Rails AppでActiveRecord::Migrationを使う + Rakeでバージョン管理する</a></li>
</ul>


<h3>rake タスクを実行する</h3>

<p>まずは rake タスクの確認。</p>

<p><code>sh
$ bundle exec rake -T
rake migrate  # Migrate database
</code></p>

<p>開発環境設定で実行する。(ENV=development)</p>

<p>```sh</p>

<h1>debug 用に&mdash;traceオプションをつけ、標準エラーをlog/trace.txtへリダイレクト。</h1>

<h1>bundle exec rake ENV=development でもOK</h1>

<p>$ bundle exec rake ENV=development &mdash;trace 2> log/trace.txt
== 20140510 CreateHoges: migrating ============================================
&mdash; create_table(:hoges)
   &ndash;> 0.1159s
== 20140510 CreateHoges: migrated (0.1160s) ===================================
```</p>

<p>問題なければテーブルが作成されているはず。</p>

<p>```
mysql> show tables;
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| Tables_in_dev_********** |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| hoges                    |
| schema_migrations        |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
2 rows in set (0.00 sec)</p>

<p>mysql> desc schema_migrations;
+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+
| Field   | Type         | Null | Key | Default | Extra |
+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+
| version | varchar(255) | NO   | PRI | NULL    |       |
+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&ndash;+
1 row in set (0.00 sec)</p>

<p>mysql> select * from schema_migrations;
+&mdash;&mdash;&mdash;&mdash;&mdash;+
| version  |
+&mdash;&mdash;&mdash;&mdash;&mdash;+
| 20140510 |
+&mdash;&mdash;&mdash;&mdash;&mdash;+
1 row in set (0.00 sec)</p>

<p>mysql> desc hoges;
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| Field      | Type         | Null | Key | Default | Extra          |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| id         | int(11)      | NO   | PRI | NULL    | auto_increment |
| name       | varchar(255) | YES  |     | NULL    |                |
| url        | varchar(255) | YES  |     | NULL    |                |
| created_at | datetime     | YES  |     | NULL    |                |
| updated_at | datetime     | YES  |     | NULL    |                |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+&mdash;&mdash;&mdash;+&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&ndash;+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
5 rows in set (0.01 sec)</p>

<p>mysql> select * from hoges;
Empty set (0.00 sec)
```</p>

<h2>CRUD 操作について</h2>

<p>ActiveRecordを使って CRUD 操作する。(insert/select/update/delete)</p>

<p>ActiveRecord では、<code>ActiveRecord::Base</code> を継承したクラスがDBの1テーブルに対応し、そのクラスの属性がテーブルの各カラムに対応する。
このクラスのことを一般的に「モデル」と呼ぶ。
Rails では、Rails アプリを生成した段階で MVC 別にディレクトリが生成されるので、<code>app/models</code> 以下にこの <code>ActiveRecord::Base</code> 継承クラスを作る。
今回は Rails ではないのでそれに従う必要はない。が、モデルが増えた場合を考慮すると <code>app/models</code> 以下に整理できておいたほうがコードの可読性とかメンテナンスはしやすそうなので、<code>app/models/hoges.rb</code> ファイルを作ることにする。
Rails って理にかなっているんだな。</p>

<p><code>ruby
class Hoges &lt; ActiveRecord::Base
end
</code></p>

<p>この <code>Hoges</code> は対応するテーブル名にあわせる。これもCoC。
レコードを単数形で扱うため、テーブル名を複数形にすることが多いみたい。</p>

<h3>Create: テーブルへ insert する</h3>

<p>CRUD の C。</p>

<p><code>app.rb</code> をつくる。</p>

<p>モデルを <code>new</code> して属性値をセットしてあげればOK。</p>

<p>```ruby
require &ldquo;active_record&rdquo;
require &ldquo;yaml&rdquo;
require &ldquo;erb&rdquo;
require &ldquo;./app/models/hoges&rdquo;</p>

<p>db_conf = YAML.load( ERB.new( File.read(&ldquo;./config/database.yml&rdquo;) ).result )</p>

<h1>開発用DB接続パラメータ読み込み, 接続する</h1>

<p>ActiveRecord::Base.establish_connection(db_conf[&ldquo;db&rdquo;][&ldquo;development&rdquo;])</p>

<p>test_name = &ldquo;momota.txt&rdquo;
test_url  = &ldquo;<a href="http://momota.github.io/">http://momota.github.io/</a>&rdquo;</p>

<p>hoge = Hoges.new { |h|
  h.name = test_name
  h.url  = test_url
}
p hoge
hoge.save
p hoge
```</p>

<p>なお、<code>save</code> しないと insert されない。</p>

<p>こんな感じで生成時にハッシュを渡してもOK。</p>

<p><code>ruby
hoge = Hoges.new(:name =&gt; test_name, :url =&gt; test_url)
hoge.save
</code></p>

<p>それでは実行してみる。</p>

<p>```sh
$ bundle exec ruby app.rb</p>

<h1><Hoges id: nil, name: "momota.txt", url: "http://momota.github.io/", created_at: nil, updated_at: nil></h1>

<h1><Hoges id: 1, name: "momota.txt", url: "http://momota.github.io/", created_at: "2014-05-10 23:50:46", updated_at: "2014-05-10 23:50:46"></h1>

<p>```</p>

<p>上記から、saveしないと <code>id</code> や <code>created_at</code> などの値が空なので insert されていないことが分かる。</p>

<p>実際にテーブルの内容を見てみよう。ちゃんと insert されている。</p>

<p><code>
mysql&gt; select * from hoges;
+----+------------+--------------------------+---------------------+---------------------+
| id | name       | url                      | created_at          | updated_at          |
+----+------------+--------------------------+---------------------+---------------------+
|  1 | momota.txt | http://momota.github.io/ | 2014-05-10 23:50:46 | 2014-05-10 23:50:46 |
+----+------------+--------------------------+---------------------+---------------------+
1 row in set (0.00 sec)
</code></p>

<h3>Read: レコードを select する</h3>

<p>CRUD の R。</p>

<p>主キーで select する場合は、<code>find</code> メソッドを使う。</p>

<p><code>ruby
hoges = Hoges.find( 1 )
</code></p>

<p>これは以下の SQL と同じ。</p>

<p><code>sql
SELECT * FROM hoges where hoges.id = 1 LIMIT 1;
</code></p>

<p>主キー以外だと、<code>find_by</code> メソッドを使う。</p>

<p>該当するレコードがなければ <code>nil</code> が返ってくる。</p>

<p><code>ruby
hoges = Hoges.find_by name: "momota.txt"
</code></p>

<p>これは以下のような書き方もできる。</p>

<p><code>ruby
hoges = Hoges.where(name: "momota.txt").take
</code></p>

<p>これらは以下の SQL と同じ。</p>

<p><code>sql
SELECT * FROM hoges where hoges.name = "momota.txt" LIMIT 1;
</code></p>

<p><code>find_by</code> メソッドを使ってレコードが存在しないときにだけ insert するように <code>app.rb</code> を書き変えてみよう。</p>

<p>```diff
-hoge = Hoges.new { |h|
&ndash;  h.name = test_name
&ndash;  h.url  = test_url
&ndash;}
-p hoge
-hoge.save
-p hoge
+rec = Hoges.find_by url: test_url
+unless rec
+  hoge = Hoges.new { |h|
+    h.name = test_name
+    h.url  = test_url
+  }
+  hoge.save
+  puts &ldquo;すでにデータは insert 済みなのでここには入らない&rdquo;
+end</p>

<p>+p rec
```</p>

<p>実行すると最終行の <code>p rec</code> が呼ばれていることが分かる。</p>

<p><code>sh
$ bundle exec ruby app.rb
&lt;Hoges id: 1, name: "momota.txt", url: "http://momota.github.io/", created_at: "2014-05-10 23:50:46", updated_at: "2014-05-10 23:50:46"&gt;
</code></p>

<p><code>find_or_create_by</code> メソッドによりさらにスマートな書き方ができる。</p>

<p><code>diff
-rec = Hoges.find_by url: test_url
-unless rec
-  hoge = Hoges.new { |h|
-    h.name = test_name
-    h.url  = test_url
-  }
-  hoge.save
+rec = Hoges.find_or_create_by( url: test_url ) do |h|
+  h.name = test_name
  puts "すでにデータは insert 済みなのでここには入らない"
end
</code></p>

<p>その他いろいろと以下のページが参考になる。</p>

<ul>
<li><a href="http://edgeguides.rubyonrails.org/active_record_querying.html">Active Record Query Interface</a></li>
</ul>


<h3>Update: レコードを update する</h3>

<p>CRUD の U。</p>

<p>これはオブジェクトの属性を更新して <code>save</code> するだけ。</p>

<p><code>ruby
changed_name = "momota.log"
hoges = Hoges.find_by url: test_url
hoges.name = changed_name
hoges.save
</code></p>

<h3>Delete: レコードを delete する</h3>

<p>CRUD の D。</p>

<p>これも簡単でモデルオブジェクトから <code>destroy</code> or <code>delete</code> メソッドを呼ぶだけ。<code>save</code> は不要。</p>

<p><code>delete</code> はレコードの削除のみなので高速。<code>destroy</code> はレコードとオブジェクトも削除してくれるが、<code>delete</code> に比べて低速。</p>

<p><code>ruby
hoges = Hoges.find( 1 )
hoges.destroy
</code></p>

<p><code>where</code> で複数のレコードをひっかけて全部削除したい場合は、<code>destroy_all</code> or <code>delete_all</code> メソッドを呼ぶ。</p>

<p><code>ruby
hoges = Hoges.destroy_all(url: test_url)
</code></p>

<p><code>find_by</code> してからでもOK。</p>

<p><code>ruby
hoges = Hoges.find_by url: test_url
hoges.destroy_all
</code></p>

<p><code>app.rb</code> を書き換えてみる。</p>

<p>```ruby
-rec = Hoges.find_or_create_by( url: test_url ) do |h|
+hoges = Hoges.find_or_create_by( url: test_url ) do |h|
   h.name = test_name
&ndash;  puts &ldquo;すでにデータは insert 済みなのでここには入らない&rdquo;
 end</p>

<p>-p rec
+puts &ldquo;[before delete]record count: #{Hoges.count}&rdquo;
+Hoges.delete_all(url: test_url)
```</p>

<p>実行すると、確かにレコードが削除されている。</p>

<p><code>sh
$ bundle exec ruby app.rb
[before delete]record count: 1
[after delete] record count: 0
</code></p>

<p>sqlでも確認できる。</p>

<p>```
mysql> select * from hoges;
Empty set (0.00 sec)</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails から外れた僕らは sinatra で i did it my way (3)]]></title>
    <link href="http://momota.github.io/blog/2013/09/23/sinatra/"/>
    <updated>2013-09-23T20:39:00+09:00</updated>
    <id>http://momota.github.io/blog/2013/09/23/sinatra</id>
    <content type="html"><![CDATA[<p><img src="http://www.sinatrarb.com/images/logo.png" alt="sinatra" /></p>

<p>今回はこれまで作った sinatra アプリケーションを PaaS の <a href="https://www.heroku.com/">heroku</a> へデプロイする。
事前に heroku には sign up しておこう。</p>

<p>最初にできあがりを示す。</p>

<p>heroku: <a href="http://sample-mongo-app.herokuapp.com/">http://sample-mongo-app.herokuapp.com/</a></p>

<p>github: <a href="https://github.com/momota/heroku_sinatra_sample">https://github.com/momota/heroku_sinatra_sample</a></p>

<hr />

<ul>
<li><a href="http://momota.github.io/blog/2013/09/16/sinatra/">rails から外れた僕らは sinatra で i did it my way (1)</a>

<ul>
<li>sinatra の基本 (ルーティング、ヘルパー、フィルター、テンプレートエンジンなど)</li>
</ul>
</li>
<li><a href="http://momota.github.io/blog/2013/09/22/sinatra/">rails から外れた僕らは sinatra で i did it my way (2)</a>

<ul>
<li>sinatra で MongoDB を使ったデータ永続化</li>
<li>HTTP POSTへの対応</li>
<li>Bootstrap でのお化粧</li>
</ul>
</li>
<li><a href="http://momota.github.io/blog/2013/09/23/sinatra/">rails から外れた僕らは sinatra で i did it my way (3)</a>

<ul>
<li>sinatra の heroku へのデプロイ</li>
</ul>
</li>
</ul>


<!-- more -->


<h2>heroku toolbelt をインストールする</h2>

<p>heroku へデプロイするために heroku toolbelt をインストールする。
heroku toolbelt は  <a href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a> から環境にあったやり方を選んでインストールする。mac ではインストーラが <code>.pkg</code> 形式で配布されているので、それをぽちぽちクリックして進めればよい。</p>

<p>なお、heroku toolbelt には、以下が含まれている。</p>

<ul>
<li>heroku client: heroku アプリケーションを作成したり、管理したりする CLI ツール</li>
<li>foreman: procfile ベースでアプリケーションの管理をする</li>
<li>git</li>
</ul>


<p>shell でバージョン確認してインストールできたかを確認する。</p>

<p><code>sh
$ heroku --version
heroku-toolbelt/2.41.0 (x86_64-darwin10.8.0) ruby/1.9.3
</code></p>

<p>インストールできているようだ。</p>

<h2>heroku login</h2>

<p><code>heroku login</code> で heroku への認証を通したり、ssh キーを登録したりする。</p>

<p><code>sh
$ heroku login
Enter your Heroku credentials.
Email: makoto.momota@gmail.com
Password (typing will be hidden): ENTER_YOUR_HEROKU_PASSWORD
Authentication successful.
</code></p>

<p>私の場合は、すでにキー登録していたので、なにもキー登録操作がなかったが、初回実行の際は、以下のような感じになるらしい。</p>

<p><code>sh
Could not find an existing public key.
Would you like to generate one? [Yn]
Generating new SSH public key.
Uploading ssh public key /Users/adam/.ssh/id_rsa.pub
</code></p>

<h2>foreman で sinatra が起動できるか確認する</h2>

<p>foreman で複数の sinatra アプリケーション を管理したり、アプリケーションごとに異なる起動方法を単一に wrapping できる。
heroku では、アプリケーションを起動するために foreman が必須のようだ。
foreman でのアプリケーション起動には、 <code>Procfile</code> を書く必要がある。書式は <code>アプリケーション名: コマンド</code> を改行区切りで列挙していく。</p>

<p>ここでは、<code>mongo_app.rb</code> を起動するので、以下のように記述する。</p>

<p><code>
web: bundle exec ruby mongo_app.rb -p $PORT
</code></p>

<p>お試しに、ローカルで <code>foreman start</code> により sinatra アプリケーションを起動する。</p>

<p><code>sh
$ foreman start
17:25:31 web.1  | started with pid 10879
17:25:33 web.1  | [2013-09-23 17:25:33] INFO  WEBrick 1.3.1
17:25:33 web.1  | [2013-09-23 17:25:33] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
17:25:33 web.1  | == Sinatra/1.4.3 has taken the stage on 5000 for development with backup from WEBrick
17:25:33 web.1  | [2013-09-23 17:25:33] INFO  WEBrick::HTTPServer#start: pid=10879 port=5000
</code></p>

<p>5000 番ポートで起動したので、<a href="http://localhost:5000/">http://localhost:5000/</a> にアクセスしてみる。問題なさそう。</p>

<h2>git リポジトリを作成して push する</h2>

<p>heroku デプロイには git が必須。
git でバージョン管理していなければ、<code>git init</code> して始めよう。</p>

<p><code>sh
$ git init
$ git add .
$ git commit -m 'your commit message'
</code></p>

<h2>heroku へデプロイする</h2>

<p>いよいよ heroku 上にアプリケーションを登録する。アプリケーション名はなしでも任意の名前が付けられるが、ここでは<code>sample-mongo-app</code>にした。(のちほど変えることも可能)</p>

<p><code>sh
$ heroku apps:create sample-mongo-app
Creating sample-mongo-app... done, stack is cedar
http://sample-mongo-app.herokuapp.com/ | git@heroku.com:sample-mongo-app.git
Git remote heroku added
</code></p>

<p>このコマンドにより以下のように git リモートリポジトリに heroku リポジトリが登録される。</p>

<p><code>sh
$ git remote
heroku
$ git remote show heroku
* remote heroku
Fetch URL: git@heroku.com:sample-mongo-app.git
Push  URL: git@heroku.com:sample-mongo-app.git
HEAD branch: (unknown)
</code></p>

<p>heroku リポジトリに push することで、デプロイできる。なんとシンプルな仕組み。
ちなみに、Gemfile.lock も git で管理してないとデプロイ時にエラーとなる。</p>

<p>```sh
$ git push heroku master
Counting objects: 90, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (85/85), done.
Writing objects: 100% (90/90), 126.44 KiB, done.
Total 90 (delta 27), reused 0 (delta 0)</p>

<p>&mdash;&mdash;&ndash;> Ruby/Rack app detected
&mdash;&mdash;&ndash;> Using Ruby version: ruby-2.0.0
&mdash;&mdash;&ndash;> Installing dependencies using Bundler version 1.3.2</p>

<pre><code>   Running: bundle install --without development:test --path vendor/bundle --binstubs vendor/bundle/bin --deployment
   Fetching gem metadata from https://rubygems.org/..........
   Fetching gem metadata from https://rubygems.org/..
   Installing backports (3.3.4)
   Installing bson (1.9.2)
   Installing bson_ext (1.9.2)
   Installing eventmachine (1.0.3)
   Installing mongo (1.9.2)
   Installing rack (1.5.2)
   Installing rack-protection (1.5.0)
   Installing rack-test (0.6.2)
   Installing tilt (1.4.1)
   Installing sinatra (1.4.3)
   Installing sinatra-contrib (1.4.0)
   Using bundler (1.3.2)
   Your bundle is complete! It was installed into ./vendor/bundle
   Cleaning up the bundler cache.
</code></pre>

<p>&mdash;&mdash;&ndash;> WARNINGS:</p>

<pre><code>   You have not declared a Ruby version in your Gemfile.
   To set your Ruby version add this line to your Gemfile:
   ruby '2.0.0'
   # See https://devcenter.heroku.com/articles/ruby-versions for more information."
</code></pre>

<p>&mdash;&mdash;&ndash;> Discovering process types</p>

<pre><code>   Procfile declares types     -&gt; web
   Default types for Ruby/Rack -&gt; console, rake
</code></pre>

<p>&mdash;&mdash;&ndash;> Compiled slug size: 26.4MB
&mdash;&mdash;&ndash;> Launching&hellip; done, v3</p>

<pre><code>   http://sample-mongo-app.herokuapp.com deployed to Heroku
</code></pre>

<p>To git@heroku.com:sample-mongo-app.git
 * [new branch]      master &ndash;> master
```</p>

<h2>mongodb を heroku で使う</h2>

<p>heroku ではさまざまな add-on が提供されており、その中から mongodb のホスティングである <a href="https://addons.heroku.com/mongohq">MongoHQ</a> を利用する。</p>

<p>add-on を利用するにはクレジットカード情報の登録が必要となるので、済ませておく。<a href="https://heroku.com/verify">https://heroku.com/verify</a></p>

<p>以下で、add-on の設定をする。ここでは、無料プランの ”sandbox” を選ぶ。</p>

<p><code>sh
$ heroku addons:add mongohq:sandbox
Adding mongohq:sandbox on sample-mongo-app... done, v4 (free)
Use `heroku addons:docs mongohq` to view documentation.
$ heroku config
=== sample-mongo-app Config Vars
MONGOHQ_URL: mongodb://ID:パスワード@paulo.mongohq.com:10014/データベース名
</code></p>

<p>sinatraの DB 接続部分を mongohq 用に書き換える。</p>

<p><a href="https://devcenter.heroku.com/articles/mongohq">公式サイト</a>通り、 DB コネクションをメソッド化する。</p>

<p>```ruby
require &lsquo;sinatra&rsquo;
require &lsquo;sinatra/reloader&rsquo;
require &lsquo;mongo&rsquo;
require &lsquo;uri&rsquo;</p>

<p>def get_connection
  return @db_connection if @db_connection
  db = URI.parse(ENV[&lsquo;MONGOHQ_URL&rsquo;])
  db_name = db.path.gsub(/^\//, &lsquo;&rsquo;)
  @db_connection = Mongo::Connection.new(db.host, db.port).db(db_name)
  @db_connection.authenticate(db.user, db.password) unless (db.user.nil? || db.user.nil?)
  @db_connection
end</p>

<p>before do
  db_con = get_connection
  @comments = db_con.collection(&lsquo;comments&rsquo;)
end</p>

<p>helpers do
  # escape html
  include Rack::Utils
  alias_method :h, :escape_html
end</p>

<p>get &lsquo;/&rsquo; do
  erb :index
end</p>

<p>post &lsquo;/new&rsquo; do
  @comments.insert( :body => params[:body] )
  redirect &lsquo;/&rsquo;
end</p>

<p>post &lsquo;/delete&rsquo; do
  id = BSON::ObjectId( params[:id] )
  @comments.find(&lsquo;_id&rsquo; => id).each { |d_comment|</p>

<pre><code>@comments.remove( d_comment )
</code></pre>

<p>  }
end
```</p>

<p>これを前述したとおり、<code>git commit/push</code>してあげれば、heroku 上で sinatra アプリケーション 〜 mongodb 間の接続が確認できる。</p>

<p>私がデプロイした sinatra サンプルアプリケーションは、以下からアクセス可能。</p>

<p><a href="http://sample-mongo-app.herokuapp.com/">http://sample-mongo-app.herokuapp.com/</a></p>

<h3>heroku でのデバッグ</h3>

<p>以下でアプリケーションログを <code>tail -f</code> しているように参照できる。</p>

<p><code>sh
$ heroku logs --tail
</code></p>

<hr />

<h1>番外編</h1>

<p>heroku gem は将来的に廃止されるようで、heroku toolbelt をインストールすることを推奨する。</p>

<h2>(失敗,というか古い情報編) heroku gem をインストールする</h2>

<p>Gemfile に <code>gem "heroku"</code> を追記して bundler でインストールする。</p>

<p><code>diff
diff --git a/Gemfile b/Gemfile
index 74db599..734c191 100644
--- a/Gemfile
+++ b/Gemfile
@@ -8,4 +8,5 @@ gem "sinatra", "1.4.3"
 gem "sinatra-contrib", "1.4.0"
 gem "mongo"
 gem "bson_ext"
+gem "heroku"
</code></p>

<p><code>bundle install</code> する。</p>

<p><code>sh
$ bundle install --path vendor/bundle
Fetching gem metadata from https://rubygems.org/...........
Fetching gem metadata from https://rubygems.org/..
Resolving dependencies...
Using i18n (0.6.1)
Using multi_json (1.8.0)
Using activesupport (3.2.13)
Using builder (3.0.4)
Using activemodel (3.2.13)
Using arel (3.0.2)
Using tzinfo (0.3.37)
Using activerecord (3.2.13)
Installing addressable (2.3.5)
Using backports (3.3.4)
Using bson (1.9.2)
Using bson_ext (1.9.2)
Using eventmachine (1.0.3)
Installing excon (0.25.3)
Installing heroku-api (0.3.15)
Installing launchy (2.3.0)
Installing netrc (0.7.7)
Installing mime-types (1.25)
Installing rest-client (1.6.7)
Installing rubyzip (1.0.0)
Installing heroku (2.41.0)
Using mongo (1.9.2)
Using rack (1.5.2)
Using rack-protection (1.5.0)
Using rack-test (0.6.2)
Using tilt (1.4.1)
Using sinatra (1.4.3)
Using sinatra-contrib (1.4.0)
Using sqlite3 (1.3.7)
Using bundler (1.3.5)
Your bundle is complete!
It was installed into ./vendor/bundle
Post-install message from heroku:
 !    The `heroku` gem has been deprecated and replaced with the Heroku Toolbelt.
 !    Download and install from: https://toolbelt.heroku.com
 !    For API access, see: https://github.com/heroku/heroku.rb
</code></p>

<p>なんか heroku gem は、もう廃止されるみたいなメッセージが出た。
アンインストールすることにしよう。</p>

<h3>heroku gem アンインストール</h3>

<p>Gemfile から先ほど追加した <code>gem "heroku"</code> 行を消す。
そのあとに <code>bundle clean</code> でアンインストールする。</p>

<p><code>sh
$ bundle clean
Resolving dependencies...
Removing addressable (2.3.5)
Removing excon (0.25.3)
Removing heroku (2.41.0)
Removing heroku-api (0.3.15)
Removing launchy (2.3.0)
Removing mime-types (1.25)
Removing netrc (0.7.7)
Removing rest-client (1.6.7)
Removing rubyzip (1.0.0)
</code></p>
]]></content>
  </entry>
  
</feed>
